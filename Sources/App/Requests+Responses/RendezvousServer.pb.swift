// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: RendezvousServer.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The information about a user allowed to register with the server
struct RV_AllowedUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user name
  var name: String = String()

  /// The pin to use for registration
  var pin: UInt32 = 0

  /// The time until which the user can register (in seconds since 1.1.1970)
  var expiry: UInt32 = 0

  /// The number of tries until the registration is blocked.
  var numberOfTries: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A user who stores his/her data on the server
struct RV_InternalUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public identity key
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The time when the user was created (in seconds since 1.1.1970)
  var creationTime: UInt32 = 0

  /// The name of the user
  var name: String = String()

  /// The devices of the user, must be sorted in ascending order by their creationTime.
  var devices: [RV_InternalUser.Device] = []

  /// The time when the data was signed.
  var timestamp: UInt32 = 0

  /// The server which handles the notifications.
  var notificationServer: String = String()

  /// The signature of the user info, signed by the user identity key.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A device of an internal user.
  struct Device {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The public key of the device.
    var deviceKey: Data = SwiftProtobuf.Internal.emptyData

    /// The time when the device was created (in seconds since 1.1.1970).
    var creationTime: UInt32 = 0

    /// Indicates if the device is active.
    var isActive: Bool = false

    /// The app associated with the device.
    var application: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// A bundle to register a user and a device, and upload prekeys and topic keys.
struct RV_RegistrationBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The info about the user and the device.
  var info: RV_InternalUser {
    get {return _storage._info ?? RV_InternalUser()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  /// The registration pin for the user.
  var pin: UInt32 {
    get {return _storage._pin}
    set {_uniqueStorage()._pin = newValue}
  }

  /// The new prekeys
  var preKeys: [RV_DevicePrekey] {
    get {return _storage._preKeys}
    set {_uniqueStorage()._preKeys = newValue}
  }

  /// The topic keys
  var topicKeys: [RV_TopicKey] {
    get {return _storage._topicKeys}
    set {_uniqueStorage()._topicKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The new data for a device to download
struct RV_DeviceDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The new user info (only set if changes occured)
  var userInfo: RV_InternalUser {
    get {return _storage._userInfo ?? RV_InternalUser()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Messages about new or updated topics
  var topicUpdates: [RV_Topic] {
    get {return _storage._topicUpdates}
    set {_uniqueStorage()._topicUpdates = newValue}
  }

  /// Messages with new topic keys
  var topicKeyMessages: [RV_TopicKeyMessage] {
    get {return _storage._topicKeyMessages}
    set {_uniqueStorage()._topicKeyMessages = newValue}
  }

  /// New messages in topics
  var messages: [RV_DeviceDownload.Message] {
    get {return _storage._messages}
    set {_uniqueStorage()._messages = newValue}
  }

  /// The number of topic keys remaining for the user
  var remainingTopicKeys: UInt32 {
    get {return _storage._remainingTopicKeys}
    set {_uniqueStorage()._remainingTopicKeys = newValue}
  }

  /// The number of prekeys remaining for this device
  var remainingPreKeys: UInt32 {
    get {return _storage._remainingPreKeys}
    set {_uniqueStorage()._remainingPreKeys = newValue}
  }

  /// The delivery receipts from other users
  var receipts: [RV_DeviceDownload.Receipt] {
    get {return _storage._receipts}
    set {_uniqueStorage()._receipts = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A new message in a topic
  struct Message {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic id
    var topicID: Data {
      get {return _storage._topicID}
      set {_uniqueStorage()._topicID = newValue}
    }

    /// The state of the chain after the message
    var chain: RV_TopicState.ChainState {
      get {return _storage._chain ?? RV_TopicState.ChainState()}
      set {_uniqueStorage()._chain = newValue}
    }
    /// Returns true if `chain` has been explicitly set.
    var hasChain: Bool {return _storage._chain != nil}
    /// Clears the value of `chain`. Subsequent reads from it will return its default value.
    mutating func clearChain() {_uniqueStorage()._chain = nil}

    /// The actual message
    var content: RV_TopicUpdate {
      get {return _storage._content ?? RV_TopicUpdate()}
      set {_uniqueStorage()._content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    var hasContent: Bool {return _storage._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    mutating func clearContent() {_uniqueStorage()._content = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// A list of delivery receipts
  struct Receipt {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user sending the receipts
    var sender: Data = SwiftProtobuf.Internal.emptyData

    /// The current chain state in the topics
    var receipts: [RV_DeviceDownload.Receipt.TopicReceipt] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A receipt of a user within a topic
    struct TopicReceipt {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The topic id
      var id: Data = SwiftProtobuf.Internal.emptyData

      /// The current chain index for the user
      var index: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A device prekey is used to protect the exchange of topic prekeys.
struct RV_DevicePrekey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the prekey
  var preKey: Data = SwiftProtobuf.Internal.emptyData

  /// The signature of the prekey, signed by the device key.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The data needed to upload device prekeys to the server.
struct RV_DevicePrekeyUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the user
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The public key of the device
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication token of the device
  var authToken: Data = SwiftProtobuf.Internal.emptyData

  /// The new prekeys
  var preKeys: [RV_DevicePrekey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of prekeys for a device.
struct RV_DevicePreKeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the device.
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The number of keys available for the device.
  var remainingKeys: UInt32 = 0

  /// The prekeys of a device.
  var prekeys: [RV_DevicePrekey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Prekeys for all devices of a user.
struct RV_DevicePreKeyBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of keys included in this bundle for each device.
  var keyCount: UInt32 = 0

  /// The keys for all devices.
  var devices: [RV_DevicePreKeyList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message to a device with a new topic key.
struct RV_TopicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signature key for message signing
  var signatureKey: Data = SwiftProtobuf.Internal.emptyData

  /// The key used to encrypt the message key
  var encryptionKey: Data = SwiftProtobuf.Internal.emptyData

  /// The signature of (signatureKey | encryptionKey) with the user key
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of topic keys
struct RV_TopicKeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public topic key
  var keys: [RV_TopicKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A bundle to upload a number of topic keys
struct RV_TopicKeyBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the user
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The public key of the device uploading the keys
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication token of the device
  var authToken: Data = SwiftProtobuf.Internal.emptyData

  /// The app associated with the topic keys.
  var application: String = String()

  /// The topic keys
  var topicKeys: [RV_TopicKey] = []

  /// The list of messages to deliver to each device
  var messages: [RV_TopicKeyMessageList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to get topic keys for multiple users
struct RV_TopicKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the user
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The public key of the device
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication token of the device
  var authToken: Data = SwiftProtobuf.Internal.emptyData

  /// The app associated with the topic keys.
  var application: String = String()

  /// The new prekeys
  var users: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response to a topic key request
struct RV_TopicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The users for which topic keys where requested
  var users: [RV_TopicKeyResponse.User] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The topic key of a user
  struct User {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The public key of the user
    var publicKey: Data {
      get {return _storage._publicKey}
      set {_uniqueStorage()._publicKey = newValue}
    }

    /// The requested topic key of the user
    var topicKey: RV_TopicKey {
      get {return _storage._topicKey ?? RV_TopicKey()}
      set {_uniqueStorage()._topicKey = newValue}
    }
    /// Returns true if `topicKey` has been explicitly set.
    var hasTopicKey: Bool {return _storage._topicKey != nil}
    /// Clears the value of `topicKey`. Subsequent reads from it will return its default value.
    mutating func clearTopicKey() {_uniqueStorage()._topicKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// A message to a device with a new topic key.
struct RV_TopicKeyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The topic key
  var topicKey: RV_TopicKey {
    get {return _storage._topicKey ?? RV_TopicKey()}
    set {_uniqueStorage()._topicKey = newValue}
  }
  /// Returns true if `topicKey` has been explicitly set.
  var hasTopicKey: Bool {return _storage._topicKey != nil}
  /// Clears the value of `topicKey`. Subsequent reads from it will return its default value.
  mutating func clearTopicKey() {_uniqueStorage()._topicKey = nil}

  /// The prekey used for encryption.
  var devicePreKey: Data {
    get {return _storage._devicePreKey}
    set {_uniqueStorage()._devicePreKey = newValue}
  }

  /// The keys (signatureKey | encryptionKey) encrypted with the prekey.
  var encryptedTopicKeys: Data {
    get {return _storage._encryptedTopicKeys}
    set {_uniqueStorage()._encryptedTopicKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of topic messages
struct RV_TopicKeyMessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device receiving the messages
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The messages for a device
  var messages: [RV_TopicKeyMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message to create or update a topic
struct RV_Topic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique id of the topic
  var topicID: Data = SwiftProtobuf.Internal.emptyData

  /// The application in which the topic is created
  var application: String = String()

  /// The time when the topic message was created (in seconds since 1.1.1970)
  var creationTime: UInt32 = 0

  /// The index of the admin in the member list who signed this topic message.
  var indexOfMessageCreator: UInt32 = 0

  /// The keys and roles of all group members
  var members: [RV_Topic.MemberInfo] = []

  /// The time when the request was signed (in seconds since 1.1.1970)
  var timestamp: UInt32 = 0

  /// The signature of the request data, signed with the admin's topic signature key.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A message to distribute a topic key to a user
  struct MemberInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic signature key of the user
    var signatureKey: Data {
      get {return _storage._signatureKey}
      set {_uniqueStorage()._signatureKey = newValue}
    }

    /// The role of the user
    var role: RV_Topic.MemberInfo.Role {
      get {return _storage._role}
      set {_uniqueStorage()._role = newValue}
    }

    /// The encryption of the message key with the user's topic encryption key
    var encryptedMessageKey: Data {
      get {return _storage._encryptedMessageKey}
      set {_uniqueStorage()._encryptedMessageKey = newValue}
    }

    /// Receiver identity key, and the signature of the topic key (only set for topic creation)
    var info: RV_Topic.MemberInfo.CreationInfo {
      get {return _storage._info ?? RV_Topic.MemberInfo.CreationInfo()}
      set {_uniqueStorage()._info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    var hasInfo: Bool {return _storage._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    mutating func clearInfo() {_uniqueStorage()._info = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The permissions of each member
    enum Role: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Admins can add and delete other members and assign roles.
      case admin // = 0

      /// Participants can read and write
      case participant // = 1

      /// Observers can only read
      case observer // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .admin
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .admin
        case 1: self = .participant
        case 2: self = .observer
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .admin: return 0
        case .participant: return 1
        case .observer: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Information only added when creating a new topic.
    struct CreationInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The identity key of the user
      var userKey: Data = SwiftProtobuf.Internal.emptyData

      /// The key used to encrypt the message key
      var encryptionKey: Data = SwiftProtobuf.Internal.emptyData

      /// The signature of (signatureKey | encryptionKey) with the user key
      var signature: Data = SwiftProtobuf.Internal.emptyData

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// A verifiable chain of messages in a topic.
struct RV_MessageChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All messages in the chain
  var messages: [RV_TopicUpdate] = []

  /// The result of iteratively hashing the message signatures: h_n = h(h_n-1 | h(s_n)); h_0 = id
  var output: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The current state of a topic
struct RV_TopicState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The info about the topic
  var info: RV_Topic {
    get {return _storage._info ?? RV_Topic()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  /// The current chain state
  var chain: RV_TopicState.ChainState {
    get {return _storage._chain ?? RV_TopicState.ChainState()}
    set {_uniqueStorage()._chain = newValue}
  }
  /// Returns true if `chain` has been explicitly set.
  var hasChain: Bool {return _storage._chain != nil}
  /// Clears the value of `chain`. Subsequent reads from it will return its default value.
  mutating func clearChain() {_uniqueStorage()._chain = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current state of the message chain
  struct ChainState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The chain index for the last message
    var chainIndex: UInt32 = 0

    /// The current output of the chain
    var output: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A request to upload a message
struct RV_TopicUpdateUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the device
  var deviceKey: Data {
    get {return _storage._deviceKey}
    set {_uniqueStorage()._deviceKey = newValue}
  }

  /// The authentication token of the device
  var authToken: Data {
    get {return _storage._authToken}
    set {_uniqueStorage()._authToken = newValue}
  }

  /// The id of the topic
  var topicID: Data {
    get {return _storage._topicID}
    set {_uniqueStorage()._topicID = newValue}
  }

  /// The message to add
  var update: RV_TopicUpdate {
    get {return _storage._update ?? RV_TopicUpdate()}
    set {_uniqueStorage()._update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  var hasUpdate: Bool {return _storage._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  mutating func clearUpdate() {_uniqueStorage()._update = nil}

  /// The files to upload
  var files: [RV_TopicUpdateUpload.FileData] {
    get {return _storage._files}
    set {_uniqueStorage()._files = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The data of a file
  struct FileData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The file id
    var id: Data = SwiftProtobuf.Internal.emptyData

    /// The file data
    var data: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A message posted to a topic
struct RV_TopicUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sender's index in the list of topic members
  var indexInMemberList: UInt32 = 0

  /// The files included in the message
  var files: [RV_TopicUpdate.File] = []

  /// Metadata encrypted with the message key.
  var metadata: Data = SwiftProtobuf.Internal.emptyData

  /// The signature of the whole message (without file data) with the signature key
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An optional file associated with the message
  struct File {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the message
    var id: Data = SwiftProtobuf.Internal.emptyData

    /// The hash of the encrypted file
    var hash: Data = SwiftProtobuf.Internal.emptyData

    /// The authentication tag of the file
    var tag: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// The data stored on disk for the server
struct RV_ManagementData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The administrator authentication token
  var adminToken: Data = SwiftProtobuf.Internal.emptyData

  /// The registered users who store their data on the server
  var internalUsers: [RV_InternalUser] = []

  /// The users allowed to register, index by their names
  var allowedUsers: Dictionary<String,RV_AllowedUser> = [:]

  /// The authentication tokens of all devices (key: deviceKey, value: authToken)
  var authTokens: [RV_ManagementData.KeyValuePair] = []

  /// The server to use for push notifications
  var notificationServer: String = String()

  /// The tokens to authenticate the messages to the notification servers
  var notificationTokens: [RV_ManagementData.KeyValuePair] = []

  /// The data to send to each internal device.
  var deviceData: [RV_ManagementData.DeviceData] = []

  /// The data last sent to each internal device (in case of delivery failure)
  var oldDeviceData: [RV_ManagementData.DeviceData] = []

  /// The info about all topics currently available on the server
  var topics: [RV_TopicState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A binary key and a binary value for a dictionary
  struct KeyValuePair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key of a dictionary
    var key: Data = SwiftProtobuf.Internal.emptyData

    /// The value associated with the key
    var value: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The data to send to an internal device
  struct DeviceData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The device public key
    var deviceKey: Data {
      get {return _storage._deviceKey}
      set {_uniqueStorage()._deviceKey = newValue}
    }

    /// The data for the device
    var data: RV_DeviceDownload {
      get {return _storage._data ?? RV_DeviceDownload()}
      set {_uniqueStorage()._data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return _storage._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {_uniqueStorage()._data = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// All data of a client
struct RV_ClientData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The url to the server
  var serverURL: String {
    get {return _storage._serverURL}
    set {_uniqueStorage()._serverURL = newValue}
  }

  /// The application identifier
  var appication: String {
    get {return _storage._appication}
    set {_uniqueStorage()._appication = newValue}
  }

  /// The private identity key of the user
  var userPrivateKey: Data {
    get {return _storage._userPrivateKey}
    set {_uniqueStorage()._userPrivateKey = newValue}
  }

  /// The private key of the device
  var devicePrivateKey: Data {
    get {return _storage._devicePrivateKey}
    set {_uniqueStorage()._devicePrivateKey = newValue}
  }

  /// The public key of the device
  var devicePublicKey: Data {
    get {return _storage._devicePublicKey}
    set {_uniqueStorage()._devicePublicKey = newValue}
  }

  /// Info about the user and the devices
  var userInfo: RV_InternalUser {
    get {return _storage._userInfo ?? RV_InternalUser()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// The authentication token for the server
  var authToken: Data {
    get {return _storage._authToken}
    set {_uniqueStorage()._authToken = newValue}
  }

  /// The list of unused prekeys
  var prekeys: [RV_ClientData.KeyPair] {
    get {return _storage._prekeys}
    set {_uniqueStorage()._prekeys = newValue}
  }

  /// The list of unused topic keys
  var topicKeys: [RV_ClientData.TopicKeyPair] {
    get {return _storage._topicKeys}
    set {_uniqueStorage()._topicKeys = newValue}
  }

  /// All currently existing topics with their info
  var topics: [RV_ClientData.TopicStore] {
    get {return _storage._topics}
    set {_uniqueStorage()._topics = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An asymmetric key pair.
  struct KeyPair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The private key of the pair
    var privateKey: Data = SwiftProtobuf.Internal.emptyData

    /// The public key corresponding to the private key
    var publicKey: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A topic key
  struct TopicKeyPair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key pair used for signatures
    var signing: RV_ClientData.KeyPair {
      get {return _storage._signing ?? RV_ClientData.KeyPair()}
      set {_uniqueStorage()._signing = newValue}
    }
    /// Returns true if `signing` has been explicitly set.
    var hasSigning: Bool {return _storage._signing != nil}
    /// Clears the value of `signing`. Subsequent reads from it will return its default value.
    mutating func clearSigning() {_uniqueStorage()._signing = nil}

    /// The key pair used for encryption
    var encryption: RV_ClientData.KeyPair {
      get {return _storage._encryption ?? RV_ClientData.KeyPair()}
      set {_uniqueStorage()._encryption = newValue}
    }
    /// Returns true if `encryption` has been explicitly set.
    var hasEncryption: Bool {return _storage._encryption != nil}
    /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
    mutating func clearEncryption() {_uniqueStorage()._encryption = nil}

    /// The signature of (signatureKey | encryptionKey) with the user key
    var signature: Data {
      get {return _storage._signature}
      set {_uniqueStorage()._signature = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Info about an existing topic.
  struct TopicStore {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The info about the topic
    var info: RV_Topic {
      get {return _storage._info ?? RV_Topic()}
      set {_uniqueStorage()._info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    var hasInfo: Bool {return _storage._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    mutating func clearInfo() {_uniqueStorage()._info = nil}

    /// The symmetric message key for the topic
    var messageKey: Data {
      get {return _storage._messageKey}
      set {_uniqueStorage()._messageKey = newValue}
    }

    /// The private key used for encryptions of the message key
    var encryptionKey: Data {
      get {return _storage._encryptionKey}
      set {_uniqueStorage()._encryptionKey = newValue}
    }

    /// The signature key for signing messages
    var signatureKey: Data {
      get {return _storage._signatureKey}
      set {_uniqueStorage()._signatureKey = newValue}
    }

    /// The last message index which could be verified
    var currentChainIndex: UInt32 {
      get {return _storage._currentChainIndex}
      set {_uniqueStorage()._currentChainIndex = newValue}
    }

    //// The last output which could be verified.
    var verifiedOutput: Data {
      get {return _storage._verifiedOutput}
      set {_uniqueStorage()._verifiedOutput = newValue}
    }

    /// All messages which couldn't be verified yet.
    var unverifiedMessages: [RV_ClientData.TopicStore.UnverifiedMessage] {
      get {return _storage._unverifiedMessages}
      set {_uniqueStorage()._unverifiedMessages = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The essence of a message which could not yet be verified to be in the topic chain
    struct UnverifiedMessage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The signature of the update
      var signature: Data = SwiftProtobuf.Internal.emptyData

      /// The chain index for the last message
      var chainIndex: UInt32 = 0

      /// The current output of the chain
      var output: Data = SwiftProtobuf.Internal.emptyData

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "RV"

extension RV_AllowedUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "pin"),
    3: .same(proto: "expiry"),
    4: .same(proto: "numberOfTries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.pin)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.expiry)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numberOfTries)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.pin != 0 {
      try visitor.visitSingularUInt32Field(value: self.pin, fieldNumber: 2)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 3)
    }
    if self.numberOfTries != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberOfTries, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_AllowedUser, rhs: RV_AllowedUser) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pin != rhs.pin {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.numberOfTries != rhs.numberOfTries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_InternalUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "creationTime"),
    3: .same(proto: "name"),
    4: .same(proto: "devices"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "notificationServer"),
    7: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.creationTime)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.devices)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.timestamp)
      case 6: try decoder.decodeSingularStringField(value: &self.notificationServer)
      case 7: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.creationTime, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 5)
    }
    if !self.notificationServer.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationServer, fieldNumber: 6)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_InternalUser, rhs: RV_InternalUser) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.name != rhs.name {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.notificationServer != rhs.notificationServer {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_InternalUser.Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_InternalUser.protoMessageName + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "creationTime"),
    3: .same(proto: "isActive"),
    4: .same(proto: "application"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.creationTime)
      case 3: try decoder.decodeSingularBoolField(value: &self.isActive)
      case 4: try decoder.decodeSingularStringField(value: &self.application)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.creationTime, fieldNumber: 2)
    }
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 3)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_InternalUser.Device, rhs: RV_InternalUser.Device) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_RegistrationBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegistrationBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "pin"),
    3: .same(proto: "preKeys"),
    4: .same(proto: "topicKeys"),
  ]

  fileprivate class _StorageClass {
    var _info: RV_InternalUser? = nil
    var _pin: UInt32 = 0
    var _preKeys: [RV_DevicePrekey] = []
    var _topicKeys: [RV_TopicKey] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _info = source._info
      _pin = source._pin
      _preKeys = source._preKeys
      _topicKeys = source._topicKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._pin)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._preKeys)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._topicKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._pin != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pin, fieldNumber: 2)
      }
      if !_storage._preKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preKeys, fieldNumber: 3)
      }
      if !_storage._topicKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicKeys, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_RegistrationBundle, rhs: RV_RegistrationBundle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._info != rhs_storage._info {return false}
        if _storage._pin != rhs_storage._pin {return false}
        if _storage._preKeys != rhs_storage._preKeys {return false}
        if _storage._topicKeys != rhs_storage._topicKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DeviceDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceDownload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInfo"),
    2: .same(proto: "topicUpdates"),
    3: .same(proto: "topicKeyMessages"),
    4: .same(proto: "messages"),
    5: .same(proto: "remainingTopicKeys"),
    6: .same(proto: "remainingPreKeys"),
    7: .same(proto: "receipts"),
  ]

  fileprivate class _StorageClass {
    var _userInfo: RV_InternalUser? = nil
    var _topicUpdates: [RV_Topic] = []
    var _topicKeyMessages: [RV_TopicKeyMessage] = []
    var _messages: [RV_DeviceDownload.Message] = []
    var _remainingTopicKeys: UInt32 = 0
    var _remainingPreKeys: UInt32 = 0
    var _receipts: [RV_DeviceDownload.Receipt] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userInfo = source._userInfo
      _topicUpdates = source._topicUpdates
      _topicKeyMessages = source._topicKeyMessages
      _messages = source._messages
      _remainingTopicKeys = source._remainingTopicKeys
      _remainingPreKeys = source._remainingPreKeys
      _receipts = source._receipts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._userInfo)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._topicUpdates)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._topicKeyMessages)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._messages)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._remainingTopicKeys)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._remainingPreKeys)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._receipts)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._topicUpdates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicUpdates, fieldNumber: 2)
      }
      if !_storage._topicKeyMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicKeyMessages, fieldNumber: 3)
      }
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 4)
      }
      if _storage._remainingTopicKeys != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remainingTopicKeys, fieldNumber: 5)
      }
      if _storage._remainingPreKeys != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remainingPreKeys, fieldNumber: 6)
      }
      if !_storage._receipts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receipts, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DeviceDownload, rhs: RV_DeviceDownload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._topicUpdates != rhs_storage._topicUpdates {return false}
        if _storage._topicKeyMessages != rhs_storage._topicKeyMessages {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._remainingTopicKeys != rhs_storage._remainingTopicKeys {return false}
        if _storage._remainingPreKeys != rhs_storage._remainingPreKeys {return false}
        if _storage._receipts != rhs_storage._receipts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DeviceDownload.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_DeviceDownload.protoMessageName + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "chain"),
    3: .same(proto: "content"),
  ]

  fileprivate class _StorageClass {
    var _topicID: Data = SwiftProtobuf.Internal.emptyData
    var _chain: RV_TopicState.ChainState? = nil
    var _content: RV_TopicUpdate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topicID = source._topicID
      _chain = source._chain
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._topicID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chain)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._content)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._topicID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._topicID, fieldNumber: 1)
      }
      if let v = _storage._chain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DeviceDownload.Message, rhs: RV_DeviceDownload.Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._chain != rhs_storage._chain {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DeviceDownload.Receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_DeviceDownload.protoMessageName + ".Receipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "receipts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.sender)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.receipts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if !self.receipts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receipts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DeviceDownload.Receipt, rhs: RV_DeviceDownload.Receipt) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.receipts != rhs.receipts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DeviceDownload.Receipt.TopicReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_DeviceDownload.Receipt.protoMessageName + ".TopicReceipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DeviceDownload.Receipt.TopicReceipt, rhs: RV_DeviceDownload.Receipt.TopicReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePrekey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePrekey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preKey"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.preKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.preKey, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePrekey, rhs: RV_DevicePrekey) -> Bool {
    if lhs.preKey != rhs.preKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePrekeyUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePrekeyUploadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "deviceKey"),
    3: .same(proto: "authToken"),
    4: .same(proto: "preKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.authToken)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.preKeys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 3)
    }
    if !self.preKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePrekeyUploadRequest, rhs: RV_DevicePrekeyUploadRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.preKeys != rhs.preKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePreKeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePreKeyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "remainingKeys"),
    3: .same(proto: "prekeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.remainingKeys)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.prekeys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if self.remainingKeys != 0 {
      try visitor.visitSingularUInt32Field(value: self.remainingKeys, fieldNumber: 2)
    }
    if !self.prekeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prekeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePreKeyList, rhs: RV_DevicePreKeyList) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.remainingKeys != rhs.remainingKeys {return false}
    if lhs.prekeys != rhs.prekeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePreKeyBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePreKeyBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyCount"),
    2: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.keyCount)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.devices)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.keyCount, fieldNumber: 1)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePreKeyBundle, rhs: RV_DevicePreKeyBundle) -> Bool {
    if lhs.keyCount != rhs.keyCount {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatureKey"),
    2: .same(proto: "encryptionKey"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signatureKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.encryptionKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatureKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signatureKey, fieldNumber: 1)
    }
    if !self.encryptionKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptionKey, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKey, rhs: RV_TopicKey) -> Bool {
    if lhs.signatureKey != rhs.signatureKey {return false}
    if lhs.encryptionKey != rhs.encryptionKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyList, rhs: RV_TopicKeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "deviceKey"),
    3: .same(proto: "authToken"),
    4: .same(proto: "application"),
    5: .same(proto: "topicKeys"),
    6: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.authToken)
      case 4: try decoder.decodeSingularStringField(value: &self.application)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.topicKeys)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 3)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 4)
    }
    if !self.topicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topicKeys, fieldNumber: 5)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyBundle, rhs: RV_TopicKeyBundle) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.application != rhs.application {return false}
    if lhs.topicKeys != rhs.topicKeys {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "deviceKey"),
    3: .same(proto: "authToken"),
    4: .same(proto: "application"),
    5: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.authToken)
      case 4: try decoder.decodeSingularStringField(value: &self.application)
      case 5: try decoder.decodeRepeatedBytesField(value: &self.users)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 3)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 4)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.users, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyRequest, rhs: RV_TopicKeyRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.application != rhs.application {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.users)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyResponse, rhs: RV_TopicKeyResponse) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyResponse.User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_TopicKeyResponse.protoMessageName + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "topicKey"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Data = SwiftProtobuf.Internal.emptyData
    var _topicKey: RV_TopicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _topicKey = source._topicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._topicKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 1)
      }
      if let v = _storage._topicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyResponse.User, rhs: RV_TopicKeyResponse.User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._topicKey != rhs_storage._topicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicKey"),
    2: .same(proto: "devicePreKey"),
    3: .same(proto: "encryptedTopicKeys"),
  ]

  fileprivate class _StorageClass {
    var _topicKey: RV_TopicKey? = nil
    var _devicePreKey: Data = SwiftProtobuf.Internal.emptyData
    var _encryptedTopicKeys: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topicKey = source._topicKey
      _devicePreKey = source._devicePreKey
      _encryptedTopicKeys = source._encryptedTopicKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._topicKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._devicePreKey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._encryptedTopicKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._topicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._devicePreKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._devicePreKey, fieldNumber: 2)
      }
      if !_storage._encryptedTopicKeys.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encryptedTopicKeys, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyMessage, rhs: RV_TopicKeyMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topicKey != rhs_storage._topicKey {return false}
        if _storage._devicePreKey != rhs_storage._devicePreKey {return false}
        if _storage._encryptedTopicKeys != rhs_storage._encryptedTopicKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyMessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyMessageList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyMessageList, rhs: RV_TopicKeyMessageList) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Topic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "application"),
    3: .same(proto: "creationTime"),
    4: .same(proto: "indexOfMessageCreator"),
    5: .same(proto: "members"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.topicID)
      case 2: try decoder.decodeSingularStringField(value: &self.application)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.creationTime)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.indexOfMessageCreator)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.members)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.timestamp)
      case 7: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicID.isEmpty {
      try visitor.visitSingularBytesField(value: self.topicID, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.creationTime, fieldNumber: 3)
    }
    if self.indexOfMessageCreator != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexOfMessageCreator, fieldNumber: 4)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 6)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_Topic, rhs: RV_Topic) -> Bool {
    if lhs.topicID != rhs.topicID {return false}
    if lhs.application != rhs.application {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.indexOfMessageCreator != rhs.indexOfMessageCreator {return false}
    if lhs.members != rhs.members {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_Topic.MemberInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_Topic.protoMessageName + ".MemberInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatureKey"),
    2: .same(proto: "role"),
    3: .same(proto: "encryptedMessageKey"),
    4: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _signatureKey: Data = SwiftProtobuf.Internal.emptyData
    var _role: RV_Topic.MemberInfo.Role = .admin
    var _encryptedMessageKey: Data = SwiftProtobuf.Internal.emptyData
    var _info: RV_Topic.MemberInfo.CreationInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signatureKey = source._signatureKey
      _role = source._role
      _encryptedMessageKey = source._encryptedMessageKey
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._signatureKey)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._role)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._encryptedMessageKey)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._signatureKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signatureKey, fieldNumber: 1)
      }
      if _storage._role != .admin {
        try visitor.visitSingularEnumField(value: _storage._role, fieldNumber: 2)
      }
      if !_storage._encryptedMessageKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encryptedMessageKey, fieldNumber: 3)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_Topic.MemberInfo, rhs: RV_Topic.MemberInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signatureKey != rhs_storage._signatureKey {return false}
        if _storage._role != rhs_storage._role {return false}
        if _storage._encryptedMessageKey != rhs_storage._encryptedMessageKey {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_Topic.MemberInfo.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADMIN"),
    1: .same(proto: "PARTICIPANT"),
    2: .same(proto: "OBSERVER"),
  ]
}

extension RV_Topic.MemberInfo.CreationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_Topic.MemberInfo.protoMessageName + ".CreationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userKey"),
    2: .same(proto: "encryptionKey"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.userKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.encryptionKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.userKey, fieldNumber: 1)
    }
    if !self.encryptionKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptionKey, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_Topic.MemberInfo.CreationInfo, rhs: RV_Topic.MemberInfo.CreationInfo) -> Bool {
    if lhs.userKey != rhs.userKey {return false}
    if lhs.encryptionKey != rhs.encryptionKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_MessageChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularBytesField(value: &self.output)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularBytesField(value: self.output, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_MessageChain, rhs: RV_MessageChain) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "chain"),
  ]

  fileprivate class _StorageClass {
    var _info: RV_Topic? = nil
    var _chain: RV_TopicState.ChainState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _info = source._info
      _chain = source._chain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._chain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicState, rhs: RV_TopicState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._info != rhs_storage._info {return false}
        if _storage._chain != rhs_storage._chain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicState.ChainState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_TopicState.protoMessageName + ".ChainState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainIndex"),
    2: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.chainIndex)
      case 2: try decoder.decodeSingularBytesField(value: &self.output)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chainIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainIndex, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularBytesField(value: self.output, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicState.ChainState, rhs: RV_TopicState.ChainState) -> Bool {
    if lhs.chainIndex != rhs.chainIndex {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicUpdateUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicUpdateUpload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "authToken"),
    3: .same(proto: "topicId"),
    4: .same(proto: "update"),
    5: .same(proto: "files"),
  ]

  fileprivate class _StorageClass {
    var _deviceKey: Data = SwiftProtobuf.Internal.emptyData
    var _authToken: Data = SwiftProtobuf.Internal.emptyData
    var _topicID: Data = SwiftProtobuf.Internal.emptyData
    var _update: RV_TopicUpdate? = nil
    var _files: [RV_TopicUpdateUpload.FileData] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceKey = source._deviceKey
      _authToken = source._authToken
      _topicID = source._topicID
      _update = source._update
      _files = source._files
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._deviceKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._authToken)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._topicID)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._update)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._files)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._deviceKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceKey, fieldNumber: 1)
      }
      if !_storage._authToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._authToken, fieldNumber: 2)
      }
      if !_storage._topicID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._topicID, fieldNumber: 3)
      }
      if let v = _storage._update {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._files.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._files, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicUpdateUpload, rhs: RV_TopicUpdateUpload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceKey != rhs_storage._deviceKey {return false}
        if _storage._authToken != rhs_storage._authToken {return false}
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._update != rhs_storage._update {return false}
        if _storage._files != rhs_storage._files {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicUpdateUpload.FileData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_TopicUpdateUpload.protoMessageName + ".FileData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicUpdateUpload.FileData, rhs: RV_TopicUpdateUpload.FileData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indexInMemberList"),
    3: .same(proto: "files"),
    5: .same(proto: "metadata"),
    6: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.indexInMemberList)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.files)
      case 5: try decoder.decodeSingularBytesField(value: &self.metadata)
      case 6: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.indexInMemberList != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexInMemberList, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 5)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicUpdate, rhs: RV_TopicUpdate) -> Bool {
    if lhs.indexInMemberList != rhs.indexInMemberList {return false}
    if lhs.files != rhs.files {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicUpdate.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_TopicUpdate.protoMessageName + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "hash"),
    3: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularBytesField(value: &self.hash)
      case 3: try decoder.decodeSingularBytesField(value: &self.tag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicUpdate.File, rhs: RV_TopicUpdate.File) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ManagementData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManagementData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adminToken"),
    2: .same(proto: "internalUsers"),
    3: .same(proto: "allowedUsers"),
    4: .same(proto: "authTokens"),
    5: .same(proto: "notificationServer"),
    6: .same(proto: "notificationTokens"),
    7: .same(proto: "deviceData"),
    8: .same(proto: "oldDeviceData"),
    9: .same(proto: "topics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.adminToken)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.internalUsers)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,RV_AllowedUser>.self, value: &self.allowedUsers)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.authTokens)
      case 5: try decoder.decodeSingularStringField(value: &self.notificationServer)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.notificationTokens)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.deviceData)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.oldDeviceData)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.topics)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adminToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.adminToken, fieldNumber: 1)
    }
    if !self.internalUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.internalUsers, fieldNumber: 2)
    }
    if !self.allowedUsers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,RV_AllowedUser>.self, value: self.allowedUsers, fieldNumber: 3)
    }
    if !self.authTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authTokens, fieldNumber: 4)
    }
    if !self.notificationServer.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationServer, fieldNumber: 5)
    }
    if !self.notificationTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notificationTokens, fieldNumber: 6)
    }
    if !self.deviceData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceData, fieldNumber: 7)
    }
    if !self.oldDeviceData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldDeviceData, fieldNumber: 8)
    }
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ManagementData, rhs: RV_ManagementData) -> Bool {
    if lhs.adminToken != rhs.adminToken {return false}
    if lhs.internalUsers != rhs.internalUsers {return false}
    if lhs.allowedUsers != rhs.allowedUsers {return false}
    if lhs.authTokens != rhs.authTokens {return false}
    if lhs.notificationServer != rhs.notificationServer {return false}
    if lhs.notificationTokens != rhs.notificationTokens {return false}
    if lhs.deviceData != rhs.deviceData {return false}
    if lhs.oldDeviceData != rhs.oldDeviceData {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ManagementData.KeyValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ManagementData.protoMessageName + ".KeyValuePair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.key)
      case 2: try decoder.decodeSingularBytesField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ManagementData.KeyValuePair, rhs: RV_ManagementData.KeyValuePair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ManagementData.DeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ManagementData.protoMessageName + ".DeviceData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _deviceKey: Data = SwiftProtobuf.Internal.emptyData
    var _data: RV_DeviceDownload? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceKey = source._deviceKey
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._deviceKey)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._deviceKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceKey, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ManagementData.DeviceData, rhs: RV_ManagementData.DeviceData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceKey != rhs_storage._deviceKey {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverURL"),
    2: .same(proto: "appication"),
    3: .same(proto: "userPrivateKey"),
    4: .same(proto: "devicePrivateKey"),
    5: .same(proto: "devicePublicKey"),
    6: .same(proto: "userInfo"),
    7: .same(proto: "authToken"),
    8: .same(proto: "prekeys"),
    9: .same(proto: "topicKeys"),
    10: .same(proto: "topics"),
  ]

  fileprivate class _StorageClass {
    var _serverURL: String = String()
    var _appication: String = String()
    var _userPrivateKey: Data = SwiftProtobuf.Internal.emptyData
    var _devicePrivateKey: Data = SwiftProtobuf.Internal.emptyData
    var _devicePublicKey: Data = SwiftProtobuf.Internal.emptyData
    var _userInfo: RV_InternalUser? = nil
    var _authToken: Data = SwiftProtobuf.Internal.emptyData
    var _prekeys: [RV_ClientData.KeyPair] = []
    var _topicKeys: [RV_ClientData.TopicKeyPair] = []
    var _topics: [RV_ClientData.TopicStore] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _serverURL = source._serverURL
      _appication = source._appication
      _userPrivateKey = source._userPrivateKey
      _devicePrivateKey = source._devicePrivateKey
      _devicePublicKey = source._devicePublicKey
      _userInfo = source._userInfo
      _authToken = source._authToken
      _prekeys = source._prekeys
      _topicKeys = source._topicKeys
      _topics = source._topics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._serverURL)
        case 2: try decoder.decodeSingularStringField(value: &_storage._appication)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._userPrivateKey)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._devicePrivateKey)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._devicePublicKey)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._userInfo)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._authToken)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._prekeys)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._topicKeys)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._topics)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._serverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverURL, fieldNumber: 1)
      }
      if !_storage._appication.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appication, fieldNumber: 2)
      }
      if !_storage._userPrivateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._userPrivateKey, fieldNumber: 3)
      }
      if !_storage._devicePrivateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._devicePrivateKey, fieldNumber: 4)
      }
      if !_storage._devicePublicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._devicePublicKey, fieldNumber: 5)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._authToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._authToken, fieldNumber: 7)
      }
      if !_storage._prekeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._prekeys, fieldNumber: 8)
      }
      if !_storage._topicKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicKeys, fieldNumber: 9)
      }
      if !_storage._topics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topics, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData, rhs: RV_ClientData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serverURL != rhs_storage._serverURL {return false}
        if _storage._appication != rhs_storage._appication {return false}
        if _storage._userPrivateKey != rhs_storage._userPrivateKey {return false}
        if _storage._devicePrivateKey != rhs_storage._devicePrivateKey {return false}
        if _storage._devicePublicKey != rhs_storage._devicePublicKey {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._authToken != rhs_storage._authToken {return false}
        if _storage._prekeys != rhs_storage._prekeys {return false}
        if _storage._topicKeys != rhs_storage._topicKeys {return false}
        if _storage._topics != rhs_storage._topics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.KeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.protoMessageName + ".KeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privateKey"),
    2: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.privateKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.KeyPair, rhs: RV_ClientData.KeyPair) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.TopicKeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.protoMessageName + ".TopicKeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signing"),
    2: .same(proto: "encryption"),
    3: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _signing: RV_ClientData.KeyPair? = nil
    var _encryption: RV_ClientData.KeyPair? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signing = source._signing
      _encryption = source._encryption
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._signing)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._encryption)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._signing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._encryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.TopicKeyPair, rhs: RV_ClientData.TopicKeyPair) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signing != rhs_storage._signing {return false}
        if _storage._encryption != rhs_storage._encryption {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.TopicStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.protoMessageName + ".TopicStore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "messageKey"),
    3: .same(proto: "encryptionKey"),
    4: .same(proto: "signatureKey"),
    5: .same(proto: "currentChainIndex"),
    6: .same(proto: "verifiedOutput"),
    7: .same(proto: "unverifiedMessages"),
  ]

  fileprivate class _StorageClass {
    var _info: RV_Topic? = nil
    var _messageKey: Data = SwiftProtobuf.Internal.emptyData
    var _encryptionKey: Data = SwiftProtobuf.Internal.emptyData
    var _signatureKey: Data = SwiftProtobuf.Internal.emptyData
    var _currentChainIndex: UInt32 = 0
    var _verifiedOutput: Data = SwiftProtobuf.Internal.emptyData
    var _unverifiedMessages: [RV_ClientData.TopicStore.UnverifiedMessage] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _info = source._info
      _messageKey = source._messageKey
      _encryptionKey = source._encryptionKey
      _signatureKey = source._signatureKey
      _currentChainIndex = source._currentChainIndex
      _verifiedOutput = source._verifiedOutput
      _unverifiedMessages = source._unverifiedMessages
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._messageKey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._encryptionKey)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._signatureKey)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._currentChainIndex)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._verifiedOutput)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._unverifiedMessages)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._messageKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._messageKey, fieldNumber: 2)
      }
      if !_storage._encryptionKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encryptionKey, fieldNumber: 3)
      }
      if !_storage._signatureKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signatureKey, fieldNumber: 4)
      }
      if _storage._currentChainIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._currentChainIndex, fieldNumber: 5)
      }
      if !_storage._verifiedOutput.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._verifiedOutput, fieldNumber: 6)
      }
      if !_storage._unverifiedMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unverifiedMessages, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.TopicStore, rhs: RV_ClientData.TopicStore) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._info != rhs_storage._info {return false}
        if _storage._messageKey != rhs_storage._messageKey {return false}
        if _storage._encryptionKey != rhs_storage._encryptionKey {return false}
        if _storage._signatureKey != rhs_storage._signatureKey {return false}
        if _storage._currentChainIndex != rhs_storage._currentChainIndex {return false}
        if _storage._verifiedOutput != rhs_storage._verifiedOutput {return false}
        if _storage._unverifiedMessages != rhs_storage._unverifiedMessages {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.TopicStore.UnverifiedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.TopicStore.protoMessageName + ".UnverifiedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "chainIndex"),
    3: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signature)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.chainIndex)
      case 3: try decoder.decodeSingularBytesField(value: &self.output)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if self.chainIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainIndex, fieldNumber: 2)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularBytesField(value: self.output, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.TopicStore.UnverifiedMessage, rhs: RV_ClientData.TopicStore.UnverifiedMessage) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.chainIndex != rhs.chainIndex {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
