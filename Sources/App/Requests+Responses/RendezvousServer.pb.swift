// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Rendezvous.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The information about a user allowed to register with the server
struct RV_AllowedUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user name
  var name: String = String()

  /// The pin to use for registration
  var pin: UInt32 = 0

  /// The time until which the user can register (in seconds since 1.1.1970)
  var expiry: UInt32 = 0

  /// The number of tries until the registration is blocked.
  var numberOfTries: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A user who stores his/her data on the server
struct RV_InternalUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public identity key
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The time when the user was created (in seconds since 1.1.1970)
  var creationTime: UInt32 = 0

  /// The name of the user
  var name: String = String()

  /// The devices of the user, must be sorted in ascending order by their creationTime.
  var devices: [RV_UserDevice] = []

  /// The time when the data was signed
  var timestamp: UInt32 = 0

  /// The signature of the user info, signed by the user identity key.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A bundle to register a user and a device, and upload prekeys and topic keys.
struct RV_RegistrationBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The info about the user and the device.
  var info: RV_InternalUser {
    get {return _storage._info ?? RV_InternalUser()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  /// The registration pin for the user.
  var pin: UInt32 {
    get {return _storage._pin}
    set {_uniqueStorage()._pin = newValue}
  }

  /// The new prekeys
  var preKeys: [RV_DevicePrekey] {
    get {return _storage._preKeys}
    set {_uniqueStorage()._preKeys = newValue}
  }

  /// The topic keys
  var topicKeys: [RV_TopicKey] {
    get {return _storage._topicKeys}
    set {_uniqueStorage()._topicKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A device of an internal user
struct RV_UserDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the device
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The time when the device was created (in seconds since 1.1.1970)
  var creationTime: UInt32 = 0

  /// Indicates if the device is active
  var isActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The new data for a device to download
struct RV_DeviceDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The new user info (only set if changes occured)
  var userInfo: RV_InternalUser {
    get {return _storage._userInfo ?? RV_InternalUser()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Messages about new or updated topics
  var topicUpdates: [RV_Topic] {
    get {return _storage._topicUpdates}
    set {_uniqueStorage()._topicUpdates = newValue}
  }

  /// Messages with new topic keys
  var topicKeyMessages: [RV_TopicKeyMessage] {
    get {return _storage._topicKeyMessages}
    set {_uniqueStorage()._topicKeyMessages = newValue}
  }

  /// New messages in topics
  var messages: [RV_DeviceDownload.Message] {
    get {return _storage._messages}
    set {_uniqueStorage()._messages = newValue}
  }

  /// The number of topic keys remaining for the user
  var remainingTopicKeys: UInt32 {
    get {return _storage._remainingTopicKeys}
    set {_uniqueStorage()._remainingTopicKeys = newValue}
  }

  /// The number of prekeys remaining for this device
  var remainingPreKeys: UInt32 {
    get {return _storage._remainingPreKeys}
    set {_uniqueStorage()._remainingPreKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A new message in a topic
  struct Message {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic id
    var topicID: Data {
      get {return _storage._topicID}
      set {_uniqueStorage()._topicID = newValue}
    }

    /// The state of the chain after the message
    var chain: RV_TopicState.ChainState {
      get {return _storage._chain ?? RV_TopicState.ChainState()}
      set {_uniqueStorage()._chain = newValue}
    }
    /// Returns true if `chain` has been explicitly set.
    var hasChain: Bool {return _storage._chain != nil}
    /// Clears the value of `chain`. Subsequent reads from it will return its default value.
    mutating func clearChain() {_uniqueStorage()._chain = nil}

    /// The actual message
    var content: RV_TopicMessage {
      get {return _storage._content ?? RV_TopicMessage()}
      set {_uniqueStorage()._content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    var hasContent: Bool {return _storage._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    mutating func clearContent() {_uniqueStorage()._content = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A push token for a device
struct RV_NotificationToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of push service to use for the device.
  var pushType: RV_NotificationToken.NotificationType = .pushDisabled

  /// The binary push token for notifications
  var pushToken: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of notifications for this device.
  enum NotificationType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// No push capabilities for the device
    case pushDisabled // = 0

    /// The device is a regular iOS device
    case iosDevice // = 1

    /// The device is used for iOS development
    case iosDevelopmentDevice // = 2

    /// The device is a regular iOS device using a notification extension
    case iosNotificationExtension // = 3

    /// The device is a development iOS device using a notification extension
    case iosDevelopmentNotificationExtension // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .pushDisabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pushDisabled
      case 1: self = .iosDevice
      case 2: self = .iosDevelopmentDevice
      case 3: self = .iosNotificationExtension
      case 4: self = .iosDevelopmentNotificationExtension
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pushDisabled: return 0
      case .iosDevice: return 1
      case .iosDevelopmentDevice: return 2
      case .iosNotificationExtension: return 3
      case .iosDevelopmentNotificationExtension: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension RV_NotificationToken.NotificationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RV_NotificationToken.NotificationType] = [
    .pushDisabled,
    .iosDevice,
    .iosDevelopmentDevice,
    .iosNotificationExtension,
    .iosDevelopmentNotificationExtension,
  ]
}

#endif  // swift(>=4.2)

/// A device prekey is used to protect the exchange of topic prekeys.
struct RV_DevicePrekey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the prekey
  var preKey: Data = SwiftProtobuf.Internal.emptyData

  /// The signature of the prekey, signed by the device key.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The data needed to upload device prekeys to the server.
struct RV_DevicePrekeyUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the user
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The public key of the device
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication token of the device
  var authToken: Data = SwiftProtobuf.Internal.emptyData

  /// The new prekeys
  var preKeys: [RV_DevicePrekey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of prekeys for a device.
struct RV_DevicePreKeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the device.
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The number of keys available for the device.
  var remainingKeys: UInt32 = 0

  /// The prekeys of a device.
  var prekeys: [RV_DevicePrekey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Prekeys for all devices of a user.
struct RV_DevicePreKeyBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of keys included in this bundle for each device.
  var keyCount: UInt32 = 0

  /// The keys for all devices.
  var devices: [RV_DevicePreKeyList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message to a device with a new topic key.
struct RV_TopicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signature key for message signing
  var signatureKey: Data = SwiftProtobuf.Internal.emptyData

  /// The key used to encrypt the message key
  var encryptionKey: Data = SwiftProtobuf.Internal.emptyData

  /// The signature of (signatureKey | encryptionKey) with the user key
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of topic keys
struct RV_TopicKeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public topic key
  var keys: [RV_TopicKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A bundle to upload a number of topic keys
struct RV_TopicKeyBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the user
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The public key of the device uploading the keys
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication token of the device
  var authToken: Data = SwiftProtobuf.Internal.emptyData

  /// The topic keys
  var topicKeys: [RV_TopicKey] = []

  /// The list of messages to deliver to each device
  var messages: [RV_TopicKeyMessageList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to get topic keys for multiple users
struct RV_TopicKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the user
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The public key of the device
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication token of the device
  var authToken: Data = SwiftProtobuf.Internal.emptyData

  /// The new prekeys
  var users: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response to a topic key request
struct RV_TopicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The users for which topic keys where requested
  var users: [RV_TopicKeyResponse.User] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The topic key of a user
  struct User {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The public key of the user
    var publicKey: Data {
      get {return _storage._publicKey}
      set {_uniqueStorage()._publicKey = newValue}
    }

    /// The requested topic key of the user
    var topicKey: RV_TopicKey {
      get {return _storage._topicKey ?? RV_TopicKey()}
      set {_uniqueStorage()._topicKey = newValue}
    }
    /// Returns true if `topicKey` has been explicitly set.
    var hasTopicKey: Bool {return _storage._topicKey != nil}
    /// Clears the value of `topicKey`. Subsequent reads from it will return its default value.
    mutating func clearTopicKey() {_uniqueStorage()._topicKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// A message to a device with a new topic key.
struct RV_TopicKeyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The topic key
  var topicKey: RV_TopicKey {
    get {return _storage._topicKey ?? RV_TopicKey()}
    set {_uniqueStorage()._topicKey = newValue}
  }
  /// Returns true if `topicKey` has been explicitly set.
  var hasTopicKey: Bool {return _storage._topicKey != nil}
  /// Clears the value of `topicKey`. Subsequent reads from it will return its default value.
  mutating func clearTopicKey() {_uniqueStorage()._topicKey = nil}

  /// The prekey used for encryption.
  var devicePreKey: Data {
    get {return _storage._devicePreKey}
    set {_uniqueStorage()._devicePreKey = newValue}
  }

  /// The keys (signatureKey | encryptionKey) encrypted with the prekey.
  var encryptedTopicKeys: Data {
    get {return _storage._encryptedTopicKeys}
    set {_uniqueStorage()._encryptedTopicKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of topic messages
struct RV_TopicKeyMessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device receiving the messages
  var deviceKey: Data = SwiftProtobuf.Internal.emptyData

  /// The messages for a device
  var messages: [RV_TopicKeyMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message to create or update a topic
struct RV_Topic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique id of the topic
  var topicID: Data = SwiftProtobuf.Internal.emptyData

  /// The time when the topic message was created (in seconds since 1.1.1970)
  var creationTime: UInt32 = 0

  /// The index of the admin in the member list who signed this topic message.
  var indexOfMessageCreator: UInt32 = 0

  /// The keys and roles of all group members
  var members: [RV_Topic.MemberInfo] = []

  /// The time when the request was signed (in seconds since 1.1.1970)
  var timestamp: UInt32 = 0

  /// The signature of the request data, signed with the admin's topic signature key.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A message to distribute a topic key to a user
  struct MemberInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic signature key of the user
    var signatureKey: Data {
      get {return _storage._signatureKey}
      set {_uniqueStorage()._signatureKey = newValue}
    }

    /// The role of the user
    var role: RV_Topic.MemberInfo.Role {
      get {return _storage._role}
      set {_uniqueStorage()._role = newValue}
    }

    /// The encryption of the message key with the user's topic encryption key
    var encryptedMessageKey: Data {
      get {return _storage._encryptedMessageKey}
      set {_uniqueStorage()._encryptedMessageKey = newValue}
    }

    /// Receiver identity key, and the signature of the topic key (only set for topic creation)
    var info: RV_Topic.MemberInfo.CreationInfo {
      get {return _storage._info ?? RV_Topic.MemberInfo.CreationInfo()}
      set {_uniqueStorage()._info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    var hasInfo: Bool {return _storage._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    mutating func clearInfo() {_uniqueStorage()._info = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The permissions of each member
    enum Role: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Admins can add and delete other members and assign roles.
      case admin // = 0

      /// Participants can read and write
      case participant // = 1

      /// Observers can only read
      case observer // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .admin
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .admin
        case 1: self = .participant
        case 2: self = .observer
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .admin: return 0
        case .participant: return 1
        case .observer: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Information only added when creating a new topic.
    struct CreationInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The identity key of the user
      var userKey: Data = SwiftProtobuf.Internal.emptyData

      /// The key used to encrypt the message key
      var encryptionKey: Data = SwiftProtobuf.Internal.emptyData

      /// The signature of (signatureKey | encryptionKey) with the user key
      var signature: Data = SwiftProtobuf.Internal.emptyData

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// A verifiable chain of messages in a topic.
struct RV_MessageChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All messages in the chain
  var messages: [RV_TopicMessage] = []

  /// The result of iteratively hashing the message signatures: h_n = h(h_n-1 | h(s_n)); h_0 = id
  var output: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The current state of a topic
struct RV_TopicState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The info about the topic
  var info: RV_Topic {
    get {return _storage._info ?? RV_Topic()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  /// The current chain state
  var chain: RV_TopicState.ChainState {
    get {return _storage._chain ?? RV_TopicState.ChainState()}
    set {_uniqueStorage()._chain = newValue}
  }
  /// Returns true if `chain` has been explicitly set.
  var hasChain: Bool {return _storage._chain != nil}
  /// Clears the value of `chain`. Subsequent reads from it will return its default value.
  mutating func clearChain() {_uniqueStorage()._chain = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current state of the message chain
  struct ChainState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The chain index for the next message
    var nextChainIndex: UInt32 = 0

    /// The current output of the chain
    var output: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A request to upload a message
struct RV_TopicMessageUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the device
  var deviceKey: Data {
    get {return _storage._deviceKey}
    set {_uniqueStorage()._deviceKey = newValue}
  }

  /// The authentication token of the device
  var authToken: Data {
    get {return _storage._authToken}
    set {_uniqueStorage()._authToken = newValue}
  }

  /// The id of the topic
  var topicID: Data {
    get {return _storage._topicID}
    set {_uniqueStorage()._topicID = newValue}
  }

  /// The message to add
  var message: RV_TopicMessage {
    get {return _storage._message ?? RV_TopicMessage()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// The data of the file to write to disk
  var file: Data {
    get {return _storage._file}
    set {_uniqueStorage()._file = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A message posted to a topic
struct RV_TopicMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sender's index in the list of topic members
  var indexInMemberList: UInt32 = 0

  /// The id of the file added to the topic
  var id: Data = SwiftProtobuf.Internal.emptyData

  /// The hash of the encrypted file
  var hash: Data = SwiftProtobuf.Internal.emptyData

  /// The authentication tag of the file
  var tag: Data = SwiftProtobuf.Internal.emptyData

  /// Metadata encrypted with the message key.
  var metadata: Data = SwiftProtobuf.Internal.emptyData

  /// The signature of the whole message with the signature key
  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The data stored on disk for the server
struct RV_ManagementData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The administrator authentication token
  var adminToken: Data = SwiftProtobuf.Internal.emptyData

  /// The registered users who store their data on the server
  var internalUsers: [RV_InternalUser] = []

  /// The users allowed to register, index by their names
  var allowedUsers: Dictionary<String,RV_AllowedUser> = [:]

  /// The authentication tokens of all devices
  var authTokens: [RV_ManagementData.AuthToken] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A pair of device id and authentication token
  struct AuthToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The device identifier
    var deviceKey: Data = SwiftProtobuf.Internal.emptyData

    /// The authentication token for the device
    var authToken: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// All data of a client
struct RV_ClientData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The url to the server
  var serverURL: String {
    get {return _storage._serverURL}
    set {_uniqueStorage()._serverURL = newValue}
  }

  /// The private identity key of the user
  var userPrivateKey: Data {
    get {return _storage._userPrivateKey}
    set {_uniqueStorage()._userPrivateKey = newValue}
  }

  /// The private key of the device
  var devicePrivateKey: Data {
    get {return _storage._devicePrivateKey}
    set {_uniqueStorage()._devicePrivateKey = newValue}
  }

  /// The public key of the device
  var devicePublicKey: Data {
    get {return _storage._devicePublicKey}
    set {_uniqueStorage()._devicePublicKey = newValue}
  }

  /// Info about the user and the devices
  var userInfo: RV_InternalUser {
    get {return _storage._userInfo ?? RV_InternalUser()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// The authentication token for the server
  var authToken: Data {
    get {return _storage._authToken}
    set {_uniqueStorage()._authToken = newValue}
  }

  /// The list of unused prekeys
  var prekeys: [RV_ClientData.KeyPair] {
    get {return _storage._prekeys}
    set {_uniqueStorage()._prekeys = newValue}
  }

  /// The list of unused topic keys
  var topicKeys: [RV_ClientData.TopicKeyPair] {
    get {return _storage._topicKeys}
    set {_uniqueStorage()._topicKeys = newValue}
  }

  /// All currently existing topics with their info
  var topics: [RV_ClientData.TopicStore] {
    get {return _storage._topics}
    set {_uniqueStorage()._topics = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An asymmetric key pair.
  struct KeyPair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The private key of the pair
    var privateKey: Data = SwiftProtobuf.Internal.emptyData

    /// The public key corresponding to the private key
    var publicKey: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A topic key
  struct TopicKeyPair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key pair used for signatures
    var signing: RV_ClientData.KeyPair {
      get {return _storage._signing ?? RV_ClientData.KeyPair()}
      set {_uniqueStorage()._signing = newValue}
    }
    /// Returns true if `signing` has been explicitly set.
    var hasSigning: Bool {return _storage._signing != nil}
    /// Clears the value of `signing`. Subsequent reads from it will return its default value.
    mutating func clearSigning() {_uniqueStorage()._signing = nil}

    /// The key pair used for encryption
    var encryption: RV_ClientData.KeyPair {
      get {return _storage._encryption ?? RV_ClientData.KeyPair()}
      set {_uniqueStorage()._encryption = newValue}
    }
    /// Returns true if `encryption` has been explicitly set.
    var hasEncryption: Bool {return _storage._encryption != nil}
    /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
    mutating func clearEncryption() {_uniqueStorage()._encryption = nil}

    /// The signature of (signatureKey | encryptionKey) with the user key
    var signature: Data {
      get {return _storage._signature}
      set {_uniqueStorage()._signature = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Info about an existing topic.
  struct TopicStore {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The info about the topic
    var info: RV_Topic {
      get {return _storage._info ?? RV_Topic()}
      set {_uniqueStorage()._info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    var hasInfo: Bool {return _storage._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    mutating func clearInfo() {_uniqueStorage()._info = nil}

    /// The symmetric message key for the topic
    var messageKey: Data {
      get {return _storage._messageKey}
      set {_uniqueStorage()._messageKey = newValue}
    }

    /// The private key used for encryptions of the message key
    var encryptionKey: Data {
      get {return _storage._encryptionKey}
      set {_uniqueStorage()._encryptionKey = newValue}
    }

    /// The signature key for signing messages
    var signatureKey: Data {
      get {return _storage._signatureKey}
      set {_uniqueStorage()._signatureKey = newValue}
    }

    /// The last message index which could be verified
    var nextChainIndex: UInt32 {
      get {return _storage._nextChainIndex}
      set {_uniqueStorage()._nextChainIndex = newValue}
    }

    //// The last output which could be verified.
    var verifiedOutput: Data {
      get {return _storage._verifiedOutput}
      set {_uniqueStorage()._verifiedOutput = newValue}
    }

    /// All messages which couldn't be verified yet.
    var unverifiedMessages: [RV_ClientData.TopicStore.UnverifiedMessage] {
      get {return _storage._unverifiedMessages}
      set {_uniqueStorage()._unverifiedMessages = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A message which could not yet be verified to be in the topic chain
    struct UnverifiedMessage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The public key of the sender
      var senderPublicKey: Data {
        get {return _storage._senderPublicKey}
        set {_uniqueStorage()._senderPublicKey = newValue}
      }

      /// The id of the file added to the topic
      var id: Data {
        get {return _storage._id}
        set {_uniqueStorage()._id = newValue}
      }

      /// The hash of the encrypted file
      var hash: Data {
        get {return _storage._hash}
        set {_uniqueStorage()._hash = newValue}
      }

      /// The authentication tag of the file
      var tag: Data {
        get {return _storage._tag}
        set {_uniqueStorage()._tag = newValue}
      }

      /// The metadata of the file.
      var metadata: Data {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      /// The signature of the message
      var signature: Data {
        get {return _storage._signature}
        set {_uniqueStorage()._signature = newValue}
      }

      /// The state of the chain after the message
      var chain: RV_TopicState.ChainState {
        get {return _storage._chain ?? RV_TopicState.ChainState()}
        set {_uniqueStorage()._chain = newValue}
      }
      /// Returns true if `chain` has been explicitly set.
      var hasChain: Bool {return _storage._chain != nil}
      /// Clears the value of `chain`. Subsequent reads from it will return its default value.
      mutating func clearChain() {_uniqueStorage()._chain = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "RV"

extension RV_AllowedUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "pin"),
    3: .same(proto: "expiry"),
    4: .same(proto: "numberOfTries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.pin)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.expiry)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numberOfTries)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.pin != 0 {
      try visitor.visitSingularUInt32Field(value: self.pin, fieldNumber: 2)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 3)
    }
    if self.numberOfTries != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberOfTries, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_AllowedUser, rhs: RV_AllowedUser) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pin != rhs.pin {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.numberOfTries != rhs.numberOfTries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_InternalUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "creationTime"),
    3: .same(proto: "name"),
    4: .same(proto: "devices"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.creationTime)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.devices)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.timestamp)
      case 6: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.creationTime, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 5)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_InternalUser, rhs: RV_InternalUser) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.name != rhs.name {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_RegistrationBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegistrationBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "pin"),
    3: .same(proto: "preKeys"),
    4: .same(proto: "topicKeys"),
  ]

  fileprivate class _StorageClass {
    var _info: RV_InternalUser? = nil
    var _pin: UInt32 = 0
    var _preKeys: [RV_DevicePrekey] = []
    var _topicKeys: [RV_TopicKey] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _info = source._info
      _pin = source._pin
      _preKeys = source._preKeys
      _topicKeys = source._topicKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._pin)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._preKeys)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._topicKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._pin != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pin, fieldNumber: 2)
      }
      if !_storage._preKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preKeys, fieldNumber: 3)
      }
      if !_storage._topicKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicKeys, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_RegistrationBundle, rhs: RV_RegistrationBundle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._info != rhs_storage._info {return false}
        if _storage._pin != rhs_storage._pin {return false}
        if _storage._preKeys != rhs_storage._preKeys {return false}
        if _storage._topicKeys != rhs_storage._topicKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_UserDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "creationTime"),
    3: .same(proto: "isActive"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.creationTime)
      case 3: try decoder.decodeSingularBoolField(value: &self.isActive)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.creationTime, fieldNumber: 2)
    }
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_UserDevice, rhs: RV_UserDevice) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DeviceDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceDownload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInfo"),
    2: .same(proto: "topicUpdates"),
    3: .same(proto: "topicKeyMessages"),
    4: .same(proto: "messages"),
    5: .same(proto: "remainingTopicKeys"),
    6: .same(proto: "remainingPreKeys"),
  ]

  fileprivate class _StorageClass {
    var _userInfo: RV_InternalUser? = nil
    var _topicUpdates: [RV_Topic] = []
    var _topicKeyMessages: [RV_TopicKeyMessage] = []
    var _messages: [RV_DeviceDownload.Message] = []
    var _remainingTopicKeys: UInt32 = 0
    var _remainingPreKeys: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userInfo = source._userInfo
      _topicUpdates = source._topicUpdates
      _topicKeyMessages = source._topicKeyMessages
      _messages = source._messages
      _remainingTopicKeys = source._remainingTopicKeys
      _remainingPreKeys = source._remainingPreKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._userInfo)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._topicUpdates)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._topicKeyMessages)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._messages)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._remainingTopicKeys)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._remainingPreKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._topicUpdates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicUpdates, fieldNumber: 2)
      }
      if !_storage._topicKeyMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicKeyMessages, fieldNumber: 3)
      }
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 4)
      }
      if _storage._remainingTopicKeys != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remainingTopicKeys, fieldNumber: 5)
      }
      if _storage._remainingPreKeys != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remainingPreKeys, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DeviceDownload, rhs: RV_DeviceDownload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._topicUpdates != rhs_storage._topicUpdates {return false}
        if _storage._topicKeyMessages != rhs_storage._topicKeyMessages {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._remainingTopicKeys != rhs_storage._remainingTopicKeys {return false}
        if _storage._remainingPreKeys != rhs_storage._remainingPreKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DeviceDownload.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_DeviceDownload.protoMessageName + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "chain"),
    3: .same(proto: "content"),
  ]

  fileprivate class _StorageClass {
    var _topicID: Data = SwiftProtobuf.Internal.emptyData
    var _chain: RV_TopicState.ChainState? = nil
    var _content: RV_TopicMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topicID = source._topicID
      _chain = source._chain
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._topicID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chain)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._content)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._topicID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._topicID, fieldNumber: 1)
      }
      if let v = _storage._chain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DeviceDownload.Message, rhs: RV_DeviceDownload.Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._chain != rhs_storage._chain {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_NotificationToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pushType"),
    2: .same(proto: "pushToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.pushType)
      case 2: try decoder.decodeSingularBytesField(value: &self.pushToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pushType != .pushDisabled {
      try visitor.visitSingularEnumField(value: self.pushType, fieldNumber: 1)
    }
    if !self.pushToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.pushToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_NotificationToken, rhs: RV_NotificationToken) -> Bool {
    if lhs.pushType != rhs.pushType {return false}
    if lhs.pushToken != rhs.pushToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_NotificationToken.NotificationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUSH_DISABLED"),
    1: .same(proto: "IOS_DEVICE"),
    2: .same(proto: "IOS_DEVELOPMENT_DEVICE"),
    3: .same(proto: "IOS_NOTIFICATION_EXTENSION"),
    4: .same(proto: "IOS_DEVELOPMENT_NOTIFICATION_EXTENSION"),
  ]
}

extension RV_DevicePrekey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePrekey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preKey"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.preKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.preKey, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePrekey, rhs: RV_DevicePrekey) -> Bool {
    if lhs.preKey != rhs.preKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePrekeyUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePrekeyUploadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "deviceKey"),
    3: .same(proto: "authToken"),
    4: .same(proto: "preKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.authToken)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.preKeys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 3)
    }
    if !self.preKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePrekeyUploadRequest, rhs: RV_DevicePrekeyUploadRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.preKeys != rhs.preKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePreKeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePreKeyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "remainingKeys"),
    3: .same(proto: "prekeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.remainingKeys)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.prekeys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if self.remainingKeys != 0 {
      try visitor.visitSingularUInt32Field(value: self.remainingKeys, fieldNumber: 2)
    }
    if !self.prekeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prekeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePreKeyList, rhs: RV_DevicePreKeyList) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.remainingKeys != rhs.remainingKeys {return false}
    if lhs.prekeys != rhs.prekeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_DevicePreKeyBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicePreKeyBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyCount"),
    2: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.keyCount)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.devices)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.keyCount, fieldNumber: 1)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_DevicePreKeyBundle, rhs: RV_DevicePreKeyBundle) -> Bool {
    if lhs.keyCount != rhs.keyCount {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatureKey"),
    2: .same(proto: "encryptionKey"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signatureKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.encryptionKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatureKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signatureKey, fieldNumber: 1)
    }
    if !self.encryptionKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptionKey, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKey, rhs: RV_TopicKey) -> Bool {
    if lhs.signatureKey != rhs.signatureKey {return false}
    if lhs.encryptionKey != rhs.encryptionKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyList, rhs: RV_TopicKeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "deviceKey"),
    3: .same(proto: "authToken"),
    4: .same(proto: "topicKeys"),
    5: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.authToken)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.topicKeys)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 3)
    }
    if !self.topicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topicKeys, fieldNumber: 4)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyBundle, rhs: RV_TopicKeyBundle) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.topicKeys != rhs.topicKeys {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "deviceKey"),
    3: .same(proto: "authToken"),
    4: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.authToken)
      case 4: try decoder.decodeRepeatedBytesField(value: &self.users)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 3)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.users, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyRequest, rhs: RV_TopicKeyRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.users)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyResponse, rhs: RV_TopicKeyResponse) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyResponse.User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_TopicKeyResponse.protoMessageName + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "topicKey"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Data = SwiftProtobuf.Internal.emptyData
    var _topicKey: RV_TopicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _topicKey = source._topicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._topicKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 1)
      }
      if let v = _storage._topicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyResponse.User, rhs: RV_TopicKeyResponse.User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._topicKey != rhs_storage._topicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicKey"),
    2: .same(proto: "devicePreKey"),
    3: .same(proto: "encryptedTopicKeys"),
  ]

  fileprivate class _StorageClass {
    var _topicKey: RV_TopicKey? = nil
    var _devicePreKey: Data = SwiftProtobuf.Internal.emptyData
    var _encryptedTopicKeys: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topicKey = source._topicKey
      _devicePreKey = source._devicePreKey
      _encryptedTopicKeys = source._encryptedTopicKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._topicKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._devicePreKey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._encryptedTopicKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._topicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._devicePreKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._devicePreKey, fieldNumber: 2)
      }
      if !_storage._encryptedTopicKeys.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encryptedTopicKeys, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyMessage, rhs: RV_TopicKeyMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topicKey != rhs_storage._topicKey {return false}
        if _storage._devicePreKey != rhs_storage._devicePreKey {return false}
        if _storage._encryptedTopicKeys != rhs_storage._encryptedTopicKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicKeyMessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicKeyMessageList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicKeyMessageList, rhs: RV_TopicKeyMessageList) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Topic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "creationTime"),
    3: .same(proto: "indexOfMessageCreator"),
    4: .same(proto: "members"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.topicID)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.creationTime)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.indexOfMessageCreator)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.members)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.timestamp)
      case 6: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicID.isEmpty {
      try visitor.visitSingularBytesField(value: self.topicID, fieldNumber: 1)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.creationTime, fieldNumber: 2)
    }
    if self.indexOfMessageCreator != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexOfMessageCreator, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 5)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_Topic, rhs: RV_Topic) -> Bool {
    if lhs.topicID != rhs.topicID {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.indexOfMessageCreator != rhs.indexOfMessageCreator {return false}
    if lhs.members != rhs.members {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_Topic.MemberInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_Topic.protoMessageName + ".MemberInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatureKey"),
    2: .same(proto: "role"),
    3: .same(proto: "encryptedMessageKey"),
    4: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _signatureKey: Data = SwiftProtobuf.Internal.emptyData
    var _role: RV_Topic.MemberInfo.Role = .admin
    var _encryptedMessageKey: Data = SwiftProtobuf.Internal.emptyData
    var _info: RV_Topic.MemberInfo.CreationInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signatureKey = source._signatureKey
      _role = source._role
      _encryptedMessageKey = source._encryptedMessageKey
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._signatureKey)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._role)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._encryptedMessageKey)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._signatureKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signatureKey, fieldNumber: 1)
      }
      if _storage._role != .admin {
        try visitor.visitSingularEnumField(value: _storage._role, fieldNumber: 2)
      }
      if !_storage._encryptedMessageKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encryptedMessageKey, fieldNumber: 3)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_Topic.MemberInfo, rhs: RV_Topic.MemberInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signatureKey != rhs_storage._signatureKey {return false}
        if _storage._role != rhs_storage._role {return false}
        if _storage._encryptedMessageKey != rhs_storage._encryptedMessageKey {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_Topic.MemberInfo.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADMIN"),
    1: .same(proto: "PARTICIPANT"),
    2: .same(proto: "OBSERVER"),
  ]
}

extension RV_Topic.MemberInfo.CreationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_Topic.MemberInfo.protoMessageName + ".CreationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userKey"),
    2: .same(proto: "encryptionKey"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.userKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.encryptionKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.userKey, fieldNumber: 1)
    }
    if !self.encryptionKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptionKey, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_Topic.MemberInfo.CreationInfo, rhs: RV_Topic.MemberInfo.CreationInfo) -> Bool {
    if lhs.userKey != rhs.userKey {return false}
    if lhs.encryptionKey != rhs.encryptionKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_MessageChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularBytesField(value: &self.output)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularBytesField(value: self.output, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_MessageChain, rhs: RV_MessageChain) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "chain"),
  ]

  fileprivate class _StorageClass {
    var _info: RV_Topic? = nil
    var _chain: RV_TopicState.ChainState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _info = source._info
      _chain = source._chain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._chain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicState, rhs: RV_TopicState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._info != rhs_storage._info {return false}
        if _storage._chain != rhs_storage._chain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicState.ChainState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_TopicState.protoMessageName + ".ChainState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nextChainIndex"),
    2: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.nextChainIndex)
      case 2: try decoder.decodeSingularBytesField(value: &self.output)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nextChainIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextChainIndex, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularBytesField(value: self.output, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicState.ChainState, rhs: RV_TopicState.ChainState) -> Bool {
    if lhs.nextChainIndex != rhs.nextChainIndex {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicMessageUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicMessageUpload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "authToken"),
    3: .same(proto: "topicId"),
    4: .same(proto: "message"),
    5: .same(proto: "file"),
  ]

  fileprivate class _StorageClass {
    var _deviceKey: Data = SwiftProtobuf.Internal.emptyData
    var _authToken: Data = SwiftProtobuf.Internal.emptyData
    var _topicID: Data = SwiftProtobuf.Internal.emptyData
    var _message: RV_TopicMessage? = nil
    var _file: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceKey = source._deviceKey
      _authToken = source._authToken
      _topicID = source._topicID
      _message = source._message
      _file = source._file
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._deviceKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._authToken)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._topicID)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._message)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._file)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._deviceKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceKey, fieldNumber: 1)
      }
      if !_storage._authToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._authToken, fieldNumber: 2)
      }
      if !_storage._topicID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._topicID, fieldNumber: 3)
      }
      if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._file.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._file, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicMessageUpload, rhs: RV_TopicMessageUpload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceKey != rhs_storage._deviceKey {return false}
        if _storage._authToken != rhs_storage._authToken {return false}
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._file != rhs_storage._file {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_TopicMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indexInMemberList"),
    2: .same(proto: "id"),
    3: .same(proto: "hash"),
    4: .same(proto: "tag"),
    5: .same(proto: "metadata"),
    6: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.indexInMemberList)
      case 2: try decoder.decodeSingularBytesField(value: &self.id)
      case 3: try decoder.decodeSingularBytesField(value: &self.hash)
      case 4: try decoder.decodeSingularBytesField(value: &self.tag)
      case 5: try decoder.decodeSingularBytesField(value: &self.metadata)
      case 6: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.indexInMemberList != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexInMemberList, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 3)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 5)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_TopicMessage, rhs: RV_TopicMessage) -> Bool {
    if lhs.indexInMemberList != rhs.indexInMemberList {return false}
    if lhs.id != rhs.id {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ManagementData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManagementData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adminToken"),
    2: .same(proto: "internalUsers"),
    3: .same(proto: "allowedUsers"),
    4: .same(proto: "authTokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.adminToken)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.internalUsers)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,RV_AllowedUser>.self, value: &self.allowedUsers)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.authTokens)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adminToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.adminToken, fieldNumber: 1)
    }
    if !self.internalUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.internalUsers, fieldNumber: 2)
    }
    if !self.allowedUsers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,RV_AllowedUser>.self, value: self.allowedUsers, fieldNumber: 3)
    }
    if !self.authTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authTokens, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ManagementData, rhs: RV_ManagementData) -> Bool {
    if lhs.adminToken != rhs.adminToken {return false}
    if lhs.internalUsers != rhs.internalUsers {return false}
    if lhs.allowedUsers != rhs.allowedUsers {return false}
    if lhs.authTokens != rhs.authTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ManagementData.AuthToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ManagementData.protoMessageName + ".AuthToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceKey"),
    2: .same(proto: "authToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.authToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceKey, fieldNumber: 1)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ManagementData.AuthToken, rhs: RV_ManagementData.AuthToken) -> Bool {
    if lhs.deviceKey != rhs.deviceKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverURL"),
    2: .same(proto: "userPrivateKey"),
    3: .same(proto: "devicePrivateKey"),
    4: .same(proto: "devicePublicKey"),
    5: .same(proto: "userInfo"),
    6: .same(proto: "authToken"),
    7: .same(proto: "prekeys"),
    8: .same(proto: "topicKeys"),
    9: .same(proto: "topics"),
  ]

  fileprivate class _StorageClass {
    var _serverURL: String = String()
    var _userPrivateKey: Data = SwiftProtobuf.Internal.emptyData
    var _devicePrivateKey: Data = SwiftProtobuf.Internal.emptyData
    var _devicePublicKey: Data = SwiftProtobuf.Internal.emptyData
    var _userInfo: RV_InternalUser? = nil
    var _authToken: Data = SwiftProtobuf.Internal.emptyData
    var _prekeys: [RV_ClientData.KeyPair] = []
    var _topicKeys: [RV_ClientData.TopicKeyPair] = []
    var _topics: [RV_ClientData.TopicStore] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _serverURL = source._serverURL
      _userPrivateKey = source._userPrivateKey
      _devicePrivateKey = source._devicePrivateKey
      _devicePublicKey = source._devicePublicKey
      _userInfo = source._userInfo
      _authToken = source._authToken
      _prekeys = source._prekeys
      _topicKeys = source._topicKeys
      _topics = source._topics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._serverURL)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._userPrivateKey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._devicePrivateKey)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._devicePublicKey)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._userInfo)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._authToken)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._prekeys)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._topicKeys)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._topics)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._serverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverURL, fieldNumber: 1)
      }
      if !_storage._userPrivateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._userPrivateKey, fieldNumber: 2)
      }
      if !_storage._devicePrivateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._devicePrivateKey, fieldNumber: 3)
      }
      if !_storage._devicePublicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._devicePublicKey, fieldNumber: 4)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._authToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._authToken, fieldNumber: 6)
      }
      if !_storage._prekeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._prekeys, fieldNumber: 7)
      }
      if !_storage._topicKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topicKeys, fieldNumber: 8)
      }
      if !_storage._topics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topics, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData, rhs: RV_ClientData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serverURL != rhs_storage._serverURL {return false}
        if _storage._userPrivateKey != rhs_storage._userPrivateKey {return false}
        if _storage._devicePrivateKey != rhs_storage._devicePrivateKey {return false}
        if _storage._devicePublicKey != rhs_storage._devicePublicKey {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._authToken != rhs_storage._authToken {return false}
        if _storage._prekeys != rhs_storage._prekeys {return false}
        if _storage._topicKeys != rhs_storage._topicKeys {return false}
        if _storage._topics != rhs_storage._topics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.KeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.protoMessageName + ".KeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privateKey"),
    2: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.privateKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.KeyPair, rhs: RV_ClientData.KeyPair) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.TopicKeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.protoMessageName + ".TopicKeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signing"),
    2: .same(proto: "encryption"),
    3: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _signing: RV_ClientData.KeyPair? = nil
    var _encryption: RV_ClientData.KeyPair? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signing = source._signing
      _encryption = source._encryption
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._signing)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._encryption)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._signing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._encryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.TopicKeyPair, rhs: RV_ClientData.TopicKeyPair) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signing != rhs_storage._signing {return false}
        if _storage._encryption != rhs_storage._encryption {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.TopicStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.protoMessageName + ".TopicStore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "messageKey"),
    3: .same(proto: "encryptionKey"),
    4: .same(proto: "signatureKey"),
    5: .same(proto: "nextChainIndex"),
    6: .same(proto: "verifiedOutput"),
    7: .same(proto: "unverifiedMessages"),
  ]

  fileprivate class _StorageClass {
    var _info: RV_Topic? = nil
    var _messageKey: Data = SwiftProtobuf.Internal.emptyData
    var _encryptionKey: Data = SwiftProtobuf.Internal.emptyData
    var _signatureKey: Data = SwiftProtobuf.Internal.emptyData
    var _nextChainIndex: UInt32 = 0
    var _verifiedOutput: Data = SwiftProtobuf.Internal.emptyData
    var _unverifiedMessages: [RV_ClientData.TopicStore.UnverifiedMessage] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _info = source._info
      _messageKey = source._messageKey
      _encryptionKey = source._encryptionKey
      _signatureKey = source._signatureKey
      _nextChainIndex = source._nextChainIndex
      _verifiedOutput = source._verifiedOutput
      _unverifiedMessages = source._unverifiedMessages
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._messageKey)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._encryptionKey)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._signatureKey)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._nextChainIndex)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._verifiedOutput)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._unverifiedMessages)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._messageKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._messageKey, fieldNumber: 2)
      }
      if !_storage._encryptionKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encryptionKey, fieldNumber: 3)
      }
      if !_storage._signatureKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signatureKey, fieldNumber: 4)
      }
      if _storage._nextChainIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nextChainIndex, fieldNumber: 5)
      }
      if !_storage._verifiedOutput.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._verifiedOutput, fieldNumber: 6)
      }
      if !_storage._unverifiedMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unverifiedMessages, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.TopicStore, rhs: RV_ClientData.TopicStore) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._info != rhs_storage._info {return false}
        if _storage._messageKey != rhs_storage._messageKey {return false}
        if _storage._encryptionKey != rhs_storage._encryptionKey {return false}
        if _storage._signatureKey != rhs_storage._signatureKey {return false}
        if _storage._nextChainIndex != rhs_storage._nextChainIndex {return false}
        if _storage._verifiedOutput != rhs_storage._verifiedOutput {return false}
        if _storage._unverifiedMessages != rhs_storage._unverifiedMessages {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RV_ClientData.TopicStore.UnverifiedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RV_ClientData.TopicStore.protoMessageName + ".UnverifiedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderPublicKey"),
    2: .same(proto: "id"),
    3: .same(proto: "hash"),
    4: .same(proto: "tag"),
    5: .same(proto: "metadata"),
    6: .same(proto: "signature"),
    7: .same(proto: "chain"),
  ]

  fileprivate class _StorageClass {
    var _senderPublicKey: Data = SwiftProtobuf.Internal.emptyData
    var _id: Data = SwiftProtobuf.Internal.emptyData
    var _hash: Data = SwiftProtobuf.Internal.emptyData
    var _tag: Data = SwiftProtobuf.Internal.emptyData
    var _metadata: Data = SwiftProtobuf.Internal.emptyData
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _chain: RV_TopicState.ChainState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _senderPublicKey = source._senderPublicKey
      _id = source._id
      _hash = source._hash
      _tag = source._tag
      _metadata = source._metadata
      _signature = source._signature
      _chain = source._chain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._senderPublicKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._id)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._hash)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._tag)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._metadata)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._chain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._senderPublicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._senderPublicKey, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._hash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hash, fieldNumber: 3)
      }
      if !_storage._tag.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._tag, fieldNumber: 4)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._metadata, fieldNumber: 5)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 6)
      }
      if let v = _storage._chain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RV_ClientData.TopicStore.UnverifiedMessage, rhs: RV_ClientData.TopicStore.UnverifiedMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._senderPublicKey != rhs_storage._senderPublicKey {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._chain != rhs_storage._chain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
